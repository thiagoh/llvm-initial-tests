// Generated by llvm2cpp - DO NOT MODIFY!

#include <algorithm>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/IRPrintingPasses.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/IR/Module.h>
#include <llvm/Pass.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
using namespace llvm;

Module *makeLLVMModule();

int main(int argc, char **argv) {
  Module *Mod = makeLLVMModule();
  verifyModule(*Mod, PrintMessageAction);
  PassManager PM;
  PM.add(createPrintModulePass(&outs()));
  PM.run(*Mod);
  return 0;
}

Module *makeLLVMModule() {
  // Module Construction
  Module *mod = new Module("loop-test.2.ll", getGlobalContext());
  mod->setDataLayout("");
  mod->setTargetTriple("x86_64-apple-macosx10.12.0");

  // Type Definitions
  StructType *StructTy_struct___sFILE = mod->getTypeByName("struct.__sFILE");
  if (!StructTy_struct___sFILE) {
    StructTy_struct___sFILE =
        StructType::create(mod->getContext(), "struct.__sFILE");
  }
  std::vector<Type *> StructTy_struct___sFILE_fields;
  PointerType *PointerTy_2 =
      PointerType::get(IntegerType::get(mod->getContext(), 8), 0);

  StructTy_struct___sFILE_fields.push_back(PointerTy_2);
  StructTy_struct___sFILE_fields.push_back(
      IntegerType::get(mod->getContext(), 32));
  StructTy_struct___sFILE_fields.push_back(
      IntegerType::get(mod->getContext(), 32));
  StructTy_struct___sFILE_fields.push_back(
      IntegerType::get(mod->getContext(), 16));
  StructTy_struct___sFILE_fields.push_back(
      IntegerType::get(mod->getContext(), 16));
  StructType *StructTy_struct___sbuf = mod->getTypeByName("struct.__sbuf");
  if (!StructTy_struct___sbuf) {
    StructTy_struct___sbuf =
        StructType::create(mod->getContext(), "struct.__sbuf");
  }
  std::vector<Type *> StructTy_struct___sbuf_fields;
  StructTy_struct___sbuf_fields.push_back(PointerTy_2);
  StructTy_struct___sbuf_fields.push_back(
      IntegerType::get(mod->getContext(), 32));
  if (StructTy_struct___sbuf->isOpaque()) {
    StructTy_struct___sbuf->setBody(StructTy_struct___sbuf_fields,
                                    /*isPacked=*/false);
  }

  StructTy_struct___sFILE_fields.push_back(StructTy_struct___sbuf);
  StructTy_struct___sFILE_fields.push_back(
      IntegerType::get(mod->getContext(), 32));
  StructTy_struct___sFILE_fields.push_back(PointerTy_2);
  std::vector<Type *> FuncTy_4_args;
  FuncTy_4_args.push_back(PointerTy_2);
  FunctionType *FuncTy_4 = FunctionType::get(
      /*Result=*/IntegerType::get(mod->getContext(), 32),
      /*Params=*/FuncTy_4_args,
      /*isVarArg=*/false);

  PointerType *PointerTy_3 = PointerType::get(FuncTy_4, 0);

  StructTy_struct___sFILE_fields.push_back(PointerTy_3);
  std::vector<Type *> FuncTy_6_args;
  FuncTy_6_args.push_back(PointerTy_2);
  FuncTy_6_args.push_back(PointerTy_2);
  FuncTy_6_args.push_back(IntegerType::get(mod->getContext(), 32));
  FunctionType *FuncTy_6 = FunctionType::get(
      /*Result=*/IntegerType::get(mod->getContext(), 32),
      /*Params=*/FuncTy_6_args,
      /*isVarArg=*/false);

  PointerType *PointerTy_5 = PointerType::get(FuncTy_6, 0);

  StructTy_struct___sFILE_fields.push_back(PointerTy_5);
  std::vector<Type *> FuncTy_8_args;
  FuncTy_8_args.push_back(PointerTy_2);
  FuncTy_8_args.push_back(IntegerType::get(mod->getContext(), 64));
  FuncTy_8_args.push_back(IntegerType::get(mod->getContext(), 32));
  FunctionType *FuncTy_8 = FunctionType::get(
      /*Result=*/IntegerType::get(mod->getContext(), 64),
      /*Params=*/FuncTy_8_args,
      /*isVarArg=*/false);

  PointerType *PointerTy_7 = PointerType::get(FuncTy_8, 0);

  StructTy_struct___sFILE_fields.push_back(PointerTy_7);
  StructTy_struct___sFILE_fields.push_back(PointerTy_5);
  StructTy_struct___sFILE_fields.push_back(StructTy_struct___sbuf);
  StructType *StructTy_struct___sFILEX = mod->getTypeByName("struct.__sFILEX");
  if (!StructTy_struct___sFILEX) {
    StructTy_struct___sFILEX =
        StructType::create(mod->getContext(), "struct.__sFILEX");
  }
  std::vector<Type *> StructTy_struct___sFILEX_fields;
  if (StructTy_struct___sFILEX->isOpaque()) {
    StructTy_struct___sFILEX->setBody(StructTy_struct___sFILEX_fields,
                                      /*isPacked=*/false);
  }

  PointerType *PointerTy_9 = PointerType::get(StructTy_struct___sFILEX, 0);

  StructTy_struct___sFILE_fields.push_back(PointerTy_9);
  StructTy_struct___sFILE_fields.push_back(
      IntegerType::get(mod->getContext(), 32));
  ArrayType *ArrayTy_10 =
      ArrayType::get(IntegerType::get(mod->getContext(), 8), 3);

  StructTy_struct___sFILE_fields.push_back(ArrayTy_10);
  ArrayType *ArrayTy_11 =
      ArrayType::get(IntegerType::get(mod->getContext(), 8), 1);

  StructTy_struct___sFILE_fields.push_back(ArrayTy_11);
  StructTy_struct___sFILE_fields.push_back(StructTy_struct___sbuf);
  StructTy_struct___sFILE_fields.push_back(
      IntegerType::get(mod->getContext(), 32));
  StructTy_struct___sFILE_fields.push_back(
      IntegerType::get(mod->getContext(), 64));
  if (StructTy_struct___sFILE->isOpaque()) {
    StructTy_struct___sFILE->setBody(StructTy_struct___sFILE_fields,
                                     /*isPacked=*/false);
  }

  PointerType *PointerTy_1 = PointerType::get(StructTy_struct___sFILE, 0);

  PointerType *PointerTy_0 = PointerType::get(PointerTy_1, 0);

  std::vector<Type *> FuncTy_12_args;
  FuncTy_12_args.push_back(Type::getDoubleTy(mod->getContext()));
  FunctionType *FuncTy_12 = FunctionType::get(
      /*Result=*/Type::getDoubleTy(mod->getContext()),
      /*Params=*/FuncTy_12_args,
      /*isVarArg=*/false);

  PointerType *PointerTy_13 =
      PointerType::get(Type::getDoubleTy(mod->getContext()), 0);

  std::vector<Type *> FuncTy_15_args;
  FuncTy_15_args.push_back(IntegerType::get(mod->getContext(), 32));
  FuncTy_15_args.push_back(PointerTy_1);
  FunctionType *FuncTy_15 = FunctionType::get(
      /*Result=*/IntegerType::get(mod->getContext(), 32),
      /*Params=*/FuncTy_15_args,
      /*isVarArg=*/false);

  PointerType *PointerTy_14 = PointerType::get(FuncTy_15, 0);

  std::vector<Type *> FuncTy_16_args;
  FunctionType *FuncTy_16 = FunctionType::get(
      /*Result=*/IntegerType::get(mod->getContext(), 32),
      /*Params=*/FuncTy_16_args,
      /*isVarArg=*/false);

  PointerType *PointerTy_17 =
      PointerType::get(IntegerType::get(mod->getContext(), 32), 0);

  PointerType *PointerTy_18 =
      PointerType::get(Type::getFloatTy(mod->getContext()), 0);

  PointerType *PointerTy_19 = PointerType::get(FuncTy_12, 0);

  // Function Declarations

  Function *func_putchard = mod->getFunction("putchard");
  if (!func_putchard) {
    func_putchard = Function::Create(
        /*Type=*/FuncTy_12,
        /*Linkage=*/GlobalValue::ExternalLinkage,
        /*Name=*/"putchard", mod);
    func_putchard->setCallingConv(CallingConv::C);
  }
  AttributeSet func_putchard_PAL;
  {
    SmallVector<AttributeSet, 4> Attrs;
    AttributeSet PAS;
    {
      AttrBuilder B;
      B.addAttribute(Attribute::StackProtect);
      B.addAttribute(Attribute::UWTable);
      PAS = AttributeSet::get(mod->getContext(), ~0U, B);
    }

    Attrs.push_back(PAS);
    func_putchard_PAL = AttributeSet::get(mod->getContext(), Attrs);
  }
  func_putchard->setAttributes(func_putchard_PAL);

  Function *func_fputc = mod->getFunction("fputc");
  if (!func_fputc) {
    func_fputc = Function::Create(
        /*Type=*/FuncTy_15,
        /*Linkage=*/GlobalValue::ExternalLinkage,
        /*Name=*/"fputc", mod); // (external, no body)
    func_fputc->setCallingConv(CallingConv::C);
  }
  AttributeSet func_fputc_PAL;
  {
    SmallVector<AttributeSet, 4> Attrs;
    AttributeSet PAS;
    {
      AttrBuilder B;
      PAS = AttributeSet::get(mod->getContext(), ~0U, B);
    }

    Attrs.push_back(PAS);
    func_fputc_PAL = AttributeSet::get(mod->getContext(), Attrs);
  }
  func_fputc->setAttributes(func_fputc_PAL);

  Function *func_main = mod->getFunction("main");
  if (!func_main) {
    func_main = Function::Create(
        /*Type=*/FuncTy_16,
        /*Linkage=*/GlobalValue::ExternalLinkage,
        /*Name=*/"main", mod);
    func_main->setCallingConv(CallingConv::C);
  }
  AttributeSet func_main_PAL;
  {
    SmallVector<AttributeSet, 4> Attrs;
    AttributeSet PAS;
    {
      AttrBuilder B;
      B.addAttribute(Attribute::StackProtect);
      B.addAttribute(Attribute::UWTable);
      PAS = AttributeSet::get(mod->getContext(), ~0U, B);
    }

    Attrs.push_back(PAS);
    func_main_PAL = AttributeSet::get(mod->getContext(), Attrs);
  }
  func_main->setAttributes(func_main_PAL);

  // Global Variable Declarations

  GlobalVariable *gvar_ptr___stderrp =
      new GlobalVariable(/*Module=*/*mod,
                         /*Type=*/PointerTy_1,
                         /*isConstant=*/false,
                         /*Linkage=*/GlobalValue::ExternalLinkage,
                         /*Initializer=*/0,
                         /*Name=*/"__stderrp");
  gvar_ptr___stderrp->setAlignment(8);

  // Constant Definitions
  ConstantInt *const_int32_20 =
      ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));
  ConstantFP *const_double_21 =
      ConstantFP::get(mod->getContext(), APFloat(0.000000e+00));
  ConstantInt *const_int32_22 =
      ConstantInt::get(mod->getContext(), APInt(32, StringRef("0"), 10));
  ConstantFP *const_float_23 =
      ConstantFP::get(mod->getContext(), APFloat(9.700000e+01f));
  ConstantFP *const_double_24 =
      ConstantFP::get(mod->getContext(), APFloat(1.230000e+02));
  ConstantFP *const_float_25 =
      ConstantFP::get(mod->getContext(), APFloat(1.000000e+00f));

  // Global Variable Definitions

  // Function Definitions

  // Function: putchard (func_putchard)
  {
    Function::arg_iterator args = func_putchard->arg_begin();
    Value *double_X = args++;
    double_X->setName("X");

    BasicBlock *label_entry =
        BasicBlock::Create(mod->getContext(), "entry", func_putchard, 0);

    // Block entry (label_entry)
    AllocaInst *ptr_X_addr = new AllocaInst(
        Type::getDoubleTy(mod->getContext()), "X.addr", label_entry);
    ptr_X_addr->setAlignment(8);
    StoreInst *void_26 =
        new StoreInst(double_X, ptr_X_addr, false, label_entry);
    void_26->setAlignment(8);
    LoadInst *double_27 = new LoadInst(ptr_X_addr, "", false, label_entry);
    double_27->setAlignment(8);
    CastInst *int8_conv = new FPToSIInst(
        double_27, IntegerType::get(mod->getContext(), 8), "conv", label_entry);
    CastInst *int32_conv1 =
        new SExtInst(int8_conv, IntegerType::get(mod->getContext(), 32),
                     "conv1", label_entry);
    LoadInst *ptr_28 = new LoadInst(gvar_ptr___stderrp, "", false, label_entry);
    ptr_28->setAlignment(8);
    std::vector<Value *> int32_call_params;
    int32_call_params.push_back(int32_conv1);
    int32_call_params.push_back(ptr_28);
    CallInst *int32_call =
        CallInst::Create(func_fputc, int32_call_params, "call", label_entry);
    int32_call->setCallingConv(CallingConv::C);
    int32_call->setTailCall(false);
    AttributeSet int32_call_PAL;
    int32_call->setAttributes(int32_call_PAL);

    ReturnInst::Create(mod->getContext(), const_double_21, label_entry);
  }

  // Function: main (func_main)
  {

    BasicBlock *label_entry_30 =
        BasicBlock::Create(mod->getContext(), "entry", func_main, 0);
    BasicBlock *label_for_cond =
        BasicBlock::Create(mod->getContext(), "for.cond", func_main, 0);
    BasicBlock *label_for_body =
        BasicBlock::Create(mod->getContext(), "for.body", func_main, 0);
    BasicBlock *label_for_inc =
        BasicBlock::Create(mod->getContext(), "for.inc", func_main, 0);
    BasicBlock *label_for_end =
        BasicBlock::Create(mod->getContext(), "for.end", func_main, 0);

    // Block entry (label_entry_30)
    AllocaInst *ptr_retval = new AllocaInst(
        IntegerType::get(mod->getContext(), 32), "retval", label_entry_30);
    ptr_retval->setAlignment(4);
    AllocaInst *ptr_i = new AllocaInst(Type::getFloatTy(mod->getContext()), "i",
                                       label_entry_30);
    ptr_i->setAlignment(4);
    StoreInst *void_31 =
        new StoreInst(const_int32_22, ptr_retval, false, label_entry_30);
    void_31->setAlignment(4);
    StoreInst *void_32 =
        new StoreInst(const_float_23, ptr_i, false, label_entry_30);
    void_32->setAlignment(4);
    BranchInst::Create(label_for_cond, label_entry_30);

    // Block for.cond (label_for_cond)
    LoadInst *float_34 = new LoadInst(ptr_i, "", false, label_for_cond);
    float_34->setAlignment(4);
    CastInst *double_conv = new FPExtInst(
        float_34, Type::getDoubleTy(mod->getContext()), "conv", label_for_cond);
    FCmpInst *int1_cmp = new FCmpInst(*label_for_cond, FCmpInst::FCMP_OLT,
                                      double_conv, const_double_24, "cmp");
    BranchInst::Create(label_for_body, label_for_end, int1_cmp, label_for_cond);

    // Block for.body (label_for_body)
    LoadInst *float_36 = new LoadInst(ptr_i, "", false, label_for_body);
    float_36->setAlignment(4);
    CastInst *double_conv1 =
        new FPExtInst(float_36, Type::getDoubleTy(mod->getContext()), "conv1",
                      label_for_body);
    CallInst *double_call =
        CallInst::Create(func_putchard, double_conv1, "call", label_for_body);
    double_call->setCallingConv(CallingConv::C);
    double_call->setTailCall(false);
    AttributeSet double_call_PAL;
    double_call->setAttributes(double_call_PAL);

    BranchInst::Create(label_for_inc, label_for_body);

    // Block for.inc (label_for_inc)
    LoadInst *float_38 = new LoadInst(ptr_i, "", false, label_for_inc);
    float_38->setAlignment(4);
    BinaryOperator *float_inc = BinaryOperator::Create(
        Instruction::FAdd, float_38, const_float_25, "inc", label_for_inc);
    StoreInst *void_39 = new StoreInst(float_inc, ptr_i, false, label_for_inc);
    void_39->setAlignment(4);
    BranchInst::Create(label_for_cond, label_for_inc);

    // Block for.end (label_for_end)
    ReturnInst::Create(mod->getContext(), const_int32_22, label_for_end);
  }

  return mod;
}
